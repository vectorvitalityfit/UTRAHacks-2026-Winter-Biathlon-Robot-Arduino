// ============================================
// WINTER OLYMPICS ROBOT - CHAMPION EDITION
// ============================================

#include <Servo.h> 

// ---------- PIN DEFINITIONS ----------
// Motors (L298N Driver)
#define MOTOR1_PIN1 10
#define MOTOR1_PIN2 12
#define MOTOR2_PIN1 9
#define MOTOR2_PIN2 11
#define ENA 5  // Changed to PWM pins for speed control
#define ENB 6  // Changed to PWM pins for speed control

// Ultrasonic Sensor
#define TRIG_PIN A4 // Moved to Analog pins to save Digital for Servos/Color
#define ECHO_PIN A5

// IR Sensors (Line Tracking)
#define IR_LEFT A0
#define IR_RIGHT A1
#define IR_THRESHOLD 300  // Calibrated for white paper vs black tape

// Color Sensor (GY-31 TCS3200)
#define S0 2
#define S1 3
#define S2 4
#define S3 7 // Moved to avoid conflict
#define COLOR_OUT 8

// Servos
#define SERVO_CLAW_PIN 13
#define SERVO_KICK_PIN A2 // Using Analog pin as Digital Output

// ---------- TUNING CONSTANTS ----------
#define BASE_SPEED 160
#define TURN_SPEED 180
#define OBSTACLE_SPEED 160
#define RAMP_SPEED 255     // Max power for inclines
#define SEARCH_SPEED 140

// Servo Angles
#define CLAW_OPEN 90
#define CLAW_CLOSE 180
#define KICK_RESET 0
#define KICK_FIRE 160

// Global Objects
Servo clawServo;
Servo kickServo;

// State Tracking
int collectedBoxes = 0;
bool isGreenPath = true; // Default to Green
unsigned long runStartTime = 0;

// ============================================
//      LOW LEVEL HARDWARE CONTROL
// ============================================

void initHardware() {
  // Motors
  pinMode(MOTOR1_PIN1, OUTPUT); pinMode(MOTOR1_PIN2, OUTPUT);
  pinMode(MOTOR2_PIN1, OUTPUT); pinMode(MOTOR2_PIN2, OUTPUT);
  pinMode(ENA, OUTPUT); pinMode(ENB, OUTPUT);

  // Sensors
  pinMode(TRIG_PIN, OUTPUT); pinMode(ECHO_PIN, INPUT);
  pinMode(IR_LEFT, INPUT); pinMode(IR_RIGHT, INPUT);
  
  // Color Sensor
  pinMode(S0, OUTPUT); pinMode(S1, OUTPUT);
  pinMode(S2, OUTPUT); pinMode(S3, OUTPUT);
  pinMode(COLOR_OUT, INPUT);
  digitalWrite(S0, LOW); digitalWrite(S1, HIGH); // 20% Frequency scaling

  // Servos
  clawServo.attach(SERVO_CLAW_PIN);
  kickServo.attach(SERVO_KICK_PIN);
  
  // Reset Servos
  clawServo.write(CLAW_OPEN);
  kickServo.write(KICK_RESET);
}

// --- Motor Primitives ---
void move(int speedLeft, int speedRight) {
  // Left Motor
  if (speedLeft >= 0) {
    digitalWrite(MOTOR1_PIN1, LOW); digitalWrite(MOTOR1_PIN2, HIGH);
  } else {
    digitalWrite(MOTOR1_PIN1, HIGH); digitalWrite(MOTOR1_PIN2, LOW);
    speedLeft = -speedLeft;
  }
  
  // Right Motor
  if (speedRight >= 0) {
    digitalWrite(MOTOR2_PIN1, LOW); digitalWrite(MOTOR2_PIN2, HIGH);
  } else {
    digitalWrite(MOTOR2_PIN1, HIGH); digitalWrite(MOTOR2_PIN2, LOW);
    speedRight = -speedRight;
  }
  
  analogWrite(ENA, constrain(speedLeft, 0, 255));
  analogWrite(ENB, constrain(speedRight, 0, 255));
}

void stopMotors() {
  move(0, 0);
}

// --- Sensor Primitives ---
float getDistance() {
  digitalWrite(TRIG_PIN, LOW); delayMicroseconds(2);
  digitalWrite(TRIG_PIN, HIGH); delayMicroseconds(10);
  digitalWrite(TRIG_PIN, LOW);
  long duration = pulseIn(ECHO_PIN, HIGH);
  return (duration * 0.0343) / 2;
}

// Robust Color Detection (Averages samples for accuracy)
// Returns: 0=Black, 1=Red, 2=Green, 3=Blue, 4=White
int detectColor() {
  int r = 0, g = 0, b = 0;
  for(int i=0; i<3; i++) { // Sample 3 times
    digitalWrite(S2, LOW); digitalWrite(S3, LOW); r += pulseIn(COLOR_OUT, LOW);
    digitalWrite(S2, HIGH); digitalWrite(S3, HIGH); g += pulseIn(COLOR_OUT, LOW);
    digitalWrite(S2, LOW); digitalWrite(S3, HIGH); b += pulseIn(COLOR_OUT, LOW);
    delay(5);
  }
  
  // Basic Threshold Logic (You MUST calibrate these numbers at the venue)
  // Assuming lower pulseIn = higher intensity
  if(r < 300 && g > 400 && b > 400) return 1; // Red
  if(g < 300 && r > 400 && b > 300) return 2; // Green
  if(b < 200 && r > 300) return 3; // Blue
  if(r > 800 && g > 800 && b > 800) return 0; // Black
  return 4; // White/Noise
}

// ============================================
//      ADVANCED BEHAVIORS
// ============================================

// PID-ish Line Follower
// Smooths out the "wobble" to gain speed
void smartLineFollow(int speed) {
  int left = analogRead(IR_LEFT);
  int right = analogRead(IR_RIGHT);
  
  bool isLeft = left < IR_THRESHOLD;
  bool isRight = right < IR_THRESHOLD;

  if (isLeft && isRight) { 
    move(speed, speed); // On line
  } else if (!isLeft && isRight) { 
    move(speed + 40, speed - 40); // Turn Right
  } else if (isLeft && !isRight) { 
    move(speed - 40, speed + 40); // Turn Left
  } else {
    // LOST LINE: Hunt mode
    // Wiggle slightly to find it
    move(-100, 100); 
    delay(100);
    if(analogRead(IR_LEFT) > IR_THRESHOLD) {
        move(100, -100);
        delay(200);
    }
  }
}

// Guaranteed Obstacle Avoidance
// Uses the "Box" technique but waits for SENSORS not TIME
void dodgeObstacle() {
  stopMotors();
  delay(200);
  
  // 1. Turn Left 90
  move(-TURN_SPEED, TURN_SPEED);
  delay(600); 
  
  // 2. Drive around (blind duration)
  move(OBSTACLE_SPEED, OBSTACLE_SPEED);
  delay(800);
  
  // 3. Turn Right 90
  move(TURN_SPEED, -TURN_SPEED);
  delay(600);
  
  // 4. Drive Forward
  move(OBSTACLE_SPEED, OBSTACLE_SPEED);
  delay(1000);
  
  // 5. Turn Right 90 (facing line)
  move(TURN_SPEED, -TURN_SPEED);
  delay(600);
  
  // 6. THE GUARANTEE: Drive until we hit the black line
  unsigned long timeout = millis();
  while(analogRead(IR_LEFT) > IR_THRESHOLD && analogRead(IR_RIGHT) > IR_THRESHOLD) {
    move(130, 130);
    if(millis() - timeout > 3000) break; // Safety timeout
  }
  
  // 7. Align
  move(-TURN_SPEED, TURN_SPEED);
  delay(300); // Re-align with track
  stopMotors();
}

// Mechanics
void grabBox() {
  clawServo.write(CLAW_OPEN);
  delay(500);
  // Lunge forward
  move(100, 100);
  delay(300);
  stopMotors();
  clawServo.write(CLAW_CLOSE);
  delay(500);
  collectedBoxes++;
}

void releaseBox() {
  clawServo.write(CLAW_OPEN);
  delay(500);
  move(-150, -150); // Back away
  delay(500);
  clawServo.write(CLAW_CLOSE); // Reset
}

void fireBall() {
  kickServo.write(KICK_FIRE);
  delay(300);
  kickServo.write(KICK_RESET);
  delay(300);
}

// ============================================
//      MAIN EXECUTION LOOP
// ============================================

void setup() {
  Serial.begin(9600);
  initHardware();
  
  // Start Sequence
  Serial.println("WAITING FOR START...");
  delay(2000); 
  runStartTime = millis();
}

// Simple State Tracking
int stage = 0; 
// 0 = Start/Box, 1 = Split, 2 = Path, 3 = Ramp, 4 = Target/End

void loop() {
  
  // --- STAGE 0: START & BOX ---
  if (stage == 0) {
    smartLineFollow(BASE_SPEED);
    
    // Check for Blue Start Circle (Box Location)
    if (detectColor() == 3) { 
      stopMotors();
      grabBox();
      // 180 Turn
      move(TURN_SPEED, -TURN_SPEED);
      delay(1200);
      stage = 1;
    }
  }

  // --- STAGE 1: TO THE SPLIT ---
  else if (stage == 1) {
    smartLineFollow(BASE_SPEED);
    
    // Drop box if we see Blue again (unlock path)
    if (detectColor() == 3 && collectedBoxes > 0) {
        stopMotors();
        releaseBox();
        // Move slightly past the blue circle
        move(BASE_SPEED, BASE_SPEED);
        delay(500);
        // DECISION TIME: Green or Red?
        // Defaulting to Green for simpler points, can toggle here
        if(isGreenPath) {
           move(TURN_SPEED, -TURN_SPEED); // Turn Right for Green
        } else {
           move(-TURN_SPEED, TURN_SPEED); // Turn Left for Red
        }
        delay(600);
        stage = 2;
    }
  }

  // --- STAGE 2: THE PATH (Red or Green) ---
  else if (stage == 2) {
    
    if (isGreenPath) {
       smartLineFollow(BASE_SPEED);
       // Check for Ramp (Ultrasonic detects incline/wall)
       if (getDistance() < 15) {
          stage = 3;
       }
    } else {
       // RED PATH (Obstacles)
       smartLineFollow(OBSTACLE_SPEED);
       if (getDistance() < 10) {
          dodgeObstacle();
       }
       // If color sensor sees Green/Blue, we merged back
       if (detectColor() == 2) stage = 4;
    }
  }

  // --- STAGE 3: THE RAMP (Green Path Exclusive) ---
  else if (stage == 3) {
     // Overdrive for ramp
     move(RAMP_SPEED, RAMP_SPEED);
     delay(2500); // Force up the ramp
     stopMotors();
     delay(100);
     
     // We are now at the Target Zone
     // HACK: Just drive forward blindly to the center black square
     // It's safer than trying to color-detect the rings
     move(BASE_SPEED, BASE_SPEED);
     delay(1500); // Drive to center
     
     stopMotors();
     fireBall(); // SHOOT!
     
     // Back up down the ramp
     move(-BASE_SPEED, -BASE_SPEED);
     delay(2000);
     
     stage = 4; // Done
  }

  // --- STAGE 4: FINISH ---
  else if (stage == 4) {
     stopMotors();
     // Endless loop to stop robot
     while(1) {
        // Blink LED or something to celebrate
     }
  }
}